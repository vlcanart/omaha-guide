#!/usr/bin/env node
/**
 * Pre-build step: Merges ingested events, generates build metadata,
 * and writes app/events-data.js for the app to import.
 */

const fs = require("fs");
const path = require("path");

const INGESTED_PATH = path.join(__dirname, "..", "data", "events.json");
const LOG_PATH = path.join(__dirname, "..", "data", "pipeline-log.json");
const OUTPUT_PATH = path.join(__dirname, "..", "app", "events-data.js");

const CONFIG_PATH = path.join(__dirname, "pipeline", "config.js");

const TODAY = new Date().toISOString().split("T")[0];
const BUILD_TIME = new Date().toISOString();

// Load venue URL map from pipeline config (sourceId â†’ calendar URL)
let venueUrlMap = {};
try {
  const { SOURCES } = require(CONFIG_PATH);
  for (const s of SOURCES) {
    venueUrlMap[s.id] = s.url;
  }
} catch (err) {
  console.warn(`âš  Could not load pipeline config for venue URLs: ${err.message}`);
}

let ingested = [];
if (fs.existsSync(INGESTED_PATH)) {
  try {
    const raw = JSON.parse(fs.readFileSync(INGESTED_PATH, "utf8"));
    const future = raw.filter((e) => e.date >= TODAY);
    const hidden = future.filter((e) => e.status === "hidden");
    ingested = future.filter((e) => e.status !== "hidden");
    console.log(`ğŸ“… Loaded ${ingested.length} active events (${raw.length - future.length} expired, ${hidden.length} hidden, filtered out)`);
  } catch (err) {
    console.warn(`âš  Could not parse ${INGESTED_PATH}: ${err.message}`);
  }
} else {
  console.log("ğŸ“… No ingested events found â€” using seed data only");
}

// â•â•â• SMART DEDUP: merge TM data into scraped duplicates â•â•â•
// Normalize venue name for matching (lowercase, strip common suffixes)
function normalizeVenue(v) {
  return (v || "").toLowerCase().trim()
    .replace(/\b(center|arena|theatre|theater|lounge|park)\b/g, "")
    .replace(/[^a-z0-9]/g, "");
}

// Group events by normalized venue + date
const groups = {};
for (const ev of ingested) {
  const key = `${normalizeVenue(ev.venue)}|${ev.date}`;
  if (!groups[key]) groups[key] = [];
  groups[key].push(ev);
}

const dropIds = new Set();
let mergeCount = 0;

for (const [key, evs] of Object.entries(groups)) {
  if (evs.length < 2) continue;

  const tmEvents = evs.filter((e) => e.sourceId === "ticketmaster-api");
  const scraped = evs.filter((e) => e.sourceId !== "ticketmaster-api");

  if (tmEvents.length === 0 || scraped.length === 0) continue;

  // For each scraped event missing url/image, merge from the best TM match
  for (const sc of scraped) {
    if (sc.url && sc.image) continue; // already has both, skip

    // Pick the TM event (prefer one with image)
    const tm = tmEvents.find((t) => t.image) || tmEvents[0];
    if (!sc.url && tm.url) sc.url = tm.url;
    if (!sc.image && tm.image) sc.image = tm.image;
    if ((!sc.price || sc.price === "TBD") && tm.price && tm.price !== "TBD") sc.price = tm.price;
    if (tm.urlValid) sc.urlValid = true;
    if (tm.affiliatePlatform) sc.affiliatePlatform = tm.affiliatePlatform;

    // Mark all TM events in this group for removal (scraped event absorbed them)
    for (const t of tmEvents) dropIds.add(t.id);
    mergeCount++;
  }
}

// Remove absorbed TM duplicates
const beforeDedup = ingested.length;
ingested = ingested.filter((e) => !dropIds.has(e.id));
if (mergeCount > 0) {
  console.log(`ğŸ”— Merged ${mergeCount} scraped+TM duplicate pairs (dropped ${beforeDedup - ingested.length} TM dupes)`);
}

// â•â•â• VENUE URL FALLBACK: give URL-less events their venue calendar link â•â•â•
let fallbackCount = 0;
for (const ev of ingested) {
  if (!ev.url && ev.sourceId && venueUrlMap[ev.sourceId]) {
    ev.url = venueUrlMap[ev.sourceId];
    fallbackCount++;
  }
}
if (fallbackCount > 0) {
  console.log(`ğŸ”— Added venue URL fallback for ${fallbackCount} events`);
}

// Get last pipeline run info
let lastPipeline = null;
if (fs.existsSync(LOG_PATH)) {
  try {
    const log = JSON.parse(fs.readFileSync(LOG_PATH, "utf8"));
    lastPipeline = log.timestamp;
  } catch {}
}

const output = `// AUTO-GENERATED by scripts/prebuild-events.js â€” do not edit manually
// Built: ${BUILD_TIME}
// Ingested events: ${ingested.length}

export const INGESTED_EVENTS = ${JSON.stringify(ingested, null, 2)};

export const BUILD_META = {
  buildTime: "${BUILD_TIME}",
  lastPipeline: ${lastPipeline ? `"${lastPipeline}"` : "null"},
  eventCount: ${ingested.length},
};

export const dedupeKey = (e) =>
  \`\${(e.title || "").toLowerCase().trim().replace(/[^a-z0-9]/g, "")}|\${e.date}\`;
`;

fs.writeFileSync(OUTPUT_PATH, output);
console.log(`âœ“ Generated ${OUTPUT_PATH} with ${ingested.length} events (build: ${BUILD_TIME})`);
